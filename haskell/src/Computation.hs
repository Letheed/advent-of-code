{-# LANGUAGE UndecidableInstances, FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Computation
  ( Computation
  , PuzzleReport
  , PartReport
  , Result(..)
    -- ** Constructors
  , answers, answer, answer'
    -- ** Getters
  , getReports, getResult, getMessage
  ) where

import Control.DeepSeq

-- | Puzzles are of type `Computation`.
--
-- The `IO` monad is used to preserve access to files, random generators
-- and other side-effectful actions, as well as keep the execution order
-- deterministic.
type Computation = IO PuzzleReport

-- | Report generated by a puzzle.
newtype PuzzleReport = PuzzleReport [PartReport]

-- | Report generated by a puzzle part.
data PartReport = PartReport
  { result  :: Result  -- ^ Result of the puzzle part.
  , message :: String  -- ^ A message to display.
  }

-- | Result generated by a puzzle.
--
-- Used to verify that the answer is correct.
newtype Result = Result String
  deriving (Eq, NFData)

instance Show Result where
  show (Result res) = res

-- | Make a `PuzzleReport` from `PartReport`s and lift it to IO.
answers :: [PartReport] -> Computation
answers = pure . PuzzleReport

-- | Make a `PartReport` from an integer and a message.
answer :: (ToString a) => a -> String -> PartReport
answer val msg = PartReport (Result . toString $ val) msg

-- | Make a `PartReport` from an integer.
-- A basic message is generated with the passed value.
answer' :: (ToString a) => a -> PartReport
answer' val = answer val (toString val)


-- | Getter for the puzzle part reports.
getReports :: PuzzleReport -> [PartReport]
getReports (PuzzleReport reps) = reps

-- | Getter for the puzzle part's result.
getResult :: PartReport -> Result
getResult = result

-- | Getter for the puzzle part's message.
getMessage :: PartReport -> String
getMessage = message


class ToString a where
  toString :: a -> String

instance ToString String where
  toString = id

instance {-# OVERLAPPABLE #-} Show a => ToString a where
  toString = show
